# PROJECT #3: CUSTOM SOLANA PROGRAM

**OVERVIEW:** 

This project aims to develop a **decentralized application (DApp)** featuring a **calculator** implemented in **Rust**. We'll create a test using Mocha written in JavaScript, ensuring robust code validation. The following is necessary **prerequisites**—Node.js, Solana, Rust, Anchor, and Mocha—have been outlined and documented in the initial ReadMe.md of this repository.

This might look like a lot of text but we are just using two files, `/src/lib.rs` (our function) and `sol-program.ts` (our test).

**INTRO:**

In the context of Solana, **programs represent the code executed on the Solana Blockchain**. Notably, Solana programs are inherently "stateless," signifying their inability to store data. To circumvent this limitation, the solution involves the utilization of accounts. These **accounts serve as virtual "files" stored on the Solana Blockchain**, enabling essential data storage for the calculator DApp. This approach ensures efficient data management within the Solana ecosystem while adhering to the platform's architectural principles.

## Set-up
 Open a new terminal window and let's initialize our anchor project `anchor init app-name`. Once the anchor project is initialized let's test to see if everything is working fine.

 ```
anchor init sol-program
```

And open the project in VScode; 
1. Navigate to the Remote Explorer 
2. Select the `sol-program` you just created.
3. Navigate to `programs/sol-program/src/lib.rs`

![image](https://github.com/jvick1/Intro_to_SOL/assets/32043066/0749ae1b-b41a-44fe-bb2c-2cb7a837d7c8)

This is the default program that Anchor has provided. Simply, have a user-defined function called `initialize(...)` whenever initialize is called it successfully exits the program. 

## Anchor Project

With the project environment configured, we can proceed by navigating to the project directory using the terminal. Execute the following command:

```
cd sol-program
```

### Build

Once inside the project directory, the next step is to build the project using the Anchor framework. Initiate the build process with the following command:

```
anchor build
```

**This command triggers the compilation of the Rust code and generates the necessary artifacts for deploying and interacting with the Solana program.** Successful execution of the `anchor build` command is crucial for ensuring that the project is correctly compiled and ready for deployment. Any error messages or warnings during this process should be carefully addressed to guarantee the reliability and functionality of the deployed Solana program.

![image](https://github.com/jvick1/Intro_to_SOL/assets/32043066/62178822-4135-4962-8950-901eec8b5b11)

#### In the picture above, I show the **error** that I got on my run and how I solved it:
1. I got an error on my first try.
2. After a quick Google search, I found the solution,
3. adding `ahash = "=0.8.6"` to my `sol-program/programs/sol-program/Cargo.toml` file.

#### A **successful** build will look like the image below:
1. Return `Finished` in the terminal and...
2. Populate `sol-program/target/idl/sol_program.json`

![image](https://github.com/jvick1/Intro_to_SOL/assets/32043066/5b02866a-44d2-4bfa-9933-c325edd80f83)

The idl folder defines the interface description language, detailing contract instructions. It aids testing and facilitates front-end integration. Now, let's test our Solana program using Anchor. Testing ensures code reliability, and the IDL serves as a guide, aligning expectations with contract behavior. 

### Test

In `sol-program/tests/sol-program.ts` we can find the test script that gets autogenerated. 

![image](https://github.com/jvick1/Intro_to_SOL/assets/32043066/83d8f0e2-cc3f-4dde-b557-5ada966abe36)

Now, back in your terminal run `anchor test` to run our test code. If this runs successfully you should get a pass.

```
anchor test
```

![image](https://github.com/jvick1/Intro_to_SOL/assets/32043066/cd581216-3336-4ff2-940f-86ca532d5582)

## Create Function

Let's now head back to `sol-program/programs/sol-grogram/src/lib.rs` and remove the public function initialize `pub fn initialize(...)` and the public structure that calls initialize `pub struct Initialize {}`. Below I have an example of what the file, `lib.rs` should look like before (left) and after we clean it up (right). 

![image](https://github.com/jvick1/Intro_to_SOL/assets/32043066/f164b9d5-438c-4ece-9fd8-2cc3e0569da1)

Let's create our first function... this will be a public function called create `pub fn create()`. 

The *first argument* of these functions are always context `ctx: Context<Create>`. **Remember that in Solana programs are stateless which means they can't hold data.** So, if you want to store data on Solana we have to create an account which is like a file where we can store data and we can put that account on the Blockchain. Then with our program, using code, we can retrieve the data that we want from that account. 

The *next argument* will be a string called init_message `init_message: String`. This will be the greeting message displayed when we start this program. If any of this Rust code is confusing so far check out my intro to [Rust Repo](https://github.com/jvick1/Rust_Intro) I have a few intro projects there and I am adding more whenever I am not too lazy!

The *return type* will be called ProgramResult. *Inside the function*, we can write `let calculator = &mut ctx.accounts.calculator;`. This lets us get our calculator account from context we specify `&mut` because we are going to modify this account. The next line is where we modify the account and we do that with `calculator.greeting = init_message;`.  Lastly, we use `Ok(())` to let Solana know everything was run successfully. Your `lib.rs` file should look something like this:

```
//lib.rs
use anchor_lang::prelude::*;
use anchor_lang::solana_program::entrypoint::ProgramResult;

declare_id!("3PrLAA3B2KJHJKLYxWVe4ihfbh6c3pwvzPsD5dEas7mw");

#[program]
pub mod sol_program {
    use super::*;
    pub fn create(ctx: Context<Create>, init_message: String) -> ProgramResult {
        let calculator = &mut ctx.accounts.calculator;
        calculator.greeting = init_message;
        Ok(())
    }
}
```

**Be sure to add `use anchor_lang::solana_program::entrypoint::ProgramResult;`**

And there we go! You have written your first Solana Function!

## Context of our "Create" Function

The `create()` function in our Solana program plays a crucial role in managing the creation of accounts and the storage of vital data. In the Solana ecosystem, direct data storage within a program is not supported; therefore, dedicated accounts are essential for this purpose. The function takes a `ctx` parameter of type `Context<Create>`, representing a curated list of all the accounts needed for data retrieval.

Now, let's delve into specifying the accounts that constitute the context for the `create()` function. In our `lib.rs` file, under the program section, we employ a `#[derive(Accounts)]` [procedural macro](https://doc.rust-lang.org/reference/procedural-macros.html) to generate code at compile-time. This macro streamline the definition of our context, encapsulated in a `pub struct create<'info>{}`.

Within this struct, we define the accounts required for the `create()` function. For instance, a `calculator` account is introduced with attributes set by the `#[account(init, payer=user, space=264)]` macro. This macro initializes a new calculator account, designates the user as the payer responsible for the associated transaction cost, and allocates a specific space on the Solana Blockchain for the calculator account.

To ensure proper transaction signing, we include the `user` account as a `Signer` with `pub user: Signer<'info>`.

Lastly, the system program specifications for the Solana blockchain are incorporated with `pub system_program: Program<'info, System>`. It is crucial to mark the user account as mutable for proper functionality, achieved through `#[account(mut)]`.

Here's the code snippet:

```
//lib.rs
use anchor_lang::prelude::*;
use anchor_lang::solana_program::entrypoint::ProgramResult;

declare_id!("3PrLAA3B2KJHJKLYxWVe4ihfbh6c3pwvzPsD5dEas7mw");

#[program]
pub mod sol_program {
    use super::*;
    pub fn create(ctx: Context<Create>, init_message: String) -> ProgramResult {
        let calculator = &mut ctx.accounts.calculator;
        calculator.greeting = init_message;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info>{
    #[account(init, payer=user, space=264)]
    pub calculator: Account<'info, Calculator>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>
}
```

This structured and detailed context definition ensures a clear and functional integration of the `create()` function within our Solana program. Now, we just have to specify what the Account structure looks like...

## Specify the Account Structure 

We want to keep track of 3 things in our Calculator DApp.
1. The **greeting** message `init_message`
2. The **result** of whatever mathematical operation we're performing
3. The **remainder** if we are doing a division

```
//lib.rs
use anchor_lang::prelude::*;
use anchor_lang::solana_program::entrypoint::ProgramResult;

declare_id!("3PrLAA3B2KJHJKLYxWVe4ihfbh6c3pwvzPsD5dEas7mw");

#[program]
pub mod sol_program {
    use super::*;
    pub fn create(ctx: Context<Create>, init_message: String) -> ProgramResult {
        let calculator = &mut ctx.accounts.calculator;
        calculator.greeting = init_message;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info>{
    #[account(init, payer=user, space=264)]
    pub calculator: Account<'info, Calculator>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>
}

#[account]
pub struct Calculator {
    pub greeting: String,
    pub result: i64,
    pub remainder: i64
}
```

## Write a Mocha Test

Heading to our `tests/sol-program.ts` let's clear everything in this file and start from scratch. The first step is to import the needed libraries:
1. **assert:** A Node.js built-in module that provides simple assertion testing functionality, commonly used for writing test cases in JavaScript and Node.js applications.

2. **anchor:** A TypeScript library for developing on the Solana blockchain, offering a high-level interface and tools for smart contract development and interaction with the Solana blockchain.

3. **SystemProgram** (from anchor.web3): A module from the anchor.web3 package, specifically providing access to the Solana System Program, which includes functions for creating and interacting with system-level accounts and transactions on the Solana blockchain.

```
//tests/sol-program.ts
const assert = require('assert');
const anchor = require('@project-serum/anchor');
const { SystemProgram } = anchor.web3;
```

You'll get some errors from VScode but don't worry too much it's just a  bug. 

In JavaScript testing frameworks, such as Mocha and Jest, `describe()` and `it()` are functions commonly used for structuring and organizing test suites. The `describe()` function is used to group a set of related test cases or specifications. It takes two arguments: a string describing the test suite (often a feature or module name), and a callback function containing the actual test cases. The `it()` function is used for an individual test case or specification within a describe() block. It takes two arguments: a string describing the specific behavior being tested, and a callback function containing the actual test code.

Let's define our `describe()` block first. We'll want to introduce a `provider` which is  an abstraction of a connection to a Solana network. 

```
describe('sol_program', () => {
    const provider = anchor.getProvider();
    anchor.setProvider(provider);
})
```

Next, we'll create a variable for our calculator account by generating some Key Pair. We'll be using this to test our program but we need some credentials for the account we are creating so `const calculator = anchor.web3.Keypair.generate()` doesn't create or retrieve a calculator account yet but, it serves as a reference that we can call once created. Lastly, we'll make a `program` that serves as an abstraction to the Solana program we have written. If you are confused as to what should come after `anchor.workspace.xxx` just check out `target/types/sol_program.ts` it should be the very top `export type`. 

```
describe('sol_program', () => {
    const provider = anchor.getProvider();
    anchor.setProvider(provider);

    const calculator = anchor.web3.Keypair.generate();
    const program = anchor.workspace.SolProgram;
})
```

Let's dive into the code for testing our DApp! Within the `describe()` block, we'll create our first `it()` block to initiate the testing process. Let's break down the `it('Creates a calculator', async() => {})` function. The first argument specifies the name of the individual test, while the second argument is a function where the actual testing occurs.

Inside this function, we execute `await program.rpc.create()`, calling the `create()` function defined in `/src/lib.rs`. The essential parameters include the `init_message`, the context with our `accounts` (comprising calculator, user, and systemProgram), and the `signers`.

Now that the calculator is created, we proceed to perform checks by fetching the account and confirming the accuracy of the greeting message.

```
//tests/sol-program.ts

const assert = require('assert');
const anchor = require('@project-serum/anchor');
const { SystemProgram } = anchor.web3;

describe('sol_program', () => {
    const provider = anchor.getProvider();
    anchor.setProvider(provider);

    const calculator = anchor.web3.Keypair.generate();
    const program = anchor.workspace.SolProgram;

    it('Creates a calculator', async() => {
        await program.rpc.create("Welcome to Solana", {
            accounts: {
                calculator: calculator.publicKey,
                user: provider.wallet.publicKey,
                systemProgram: SystemProgram.programId
            },
            signers: [calculator]
        });

        const account = await program.account.calculator.fetch(calculator.publicKey);
        assert.ok(account.greeting == "Welcome to Solana")
    })
})
```

This testing script utilizes the `assert` library to validate that the greeting message of the newly created calculator account matches the expected value. The structured testing approach ensures the reliability and functionality of our Solana DApp.


## Let's Test It!

Back to our Ubuntu terminal let's go to our project:

```
cd sol-program
```

Check if we have a Solana Address:

```
solana address 
```

Airdrop some coins:

```
solana airdrop 2 --url devnet
```

And test:

```
anchor test
```

![image](https://github.com/jvick1/Intro_to_SOL/assets/32043066/6ef624f6-9be0-49a1-bf5e-f28baafa9e13)

## The "Addition" Function

Now that everything is up and running let's make an addition function and test that. 

Back in our `/src/lib.rs` file and under the `create()` function let's go ahead and create a `pub fn add()` function. We'll be pulling in different accounts so we'll say `ctx: Context<Addition>` and for the next two arguments we'll add in the two numbers that get added ie `num1: i64` and `num2: i64`. Then inside the function let's add the two values together and run `Ok(())` to make sure everything runs correctly. 

```
   pub fn add(ctx: Context<Addition>, num1: i64, num2: i64) -> ProgramResult {
        let calculator = &mut ctx.accounts.calculator;
        calculator.result = num1 + num2;
        Ok(())
    }
```

Next, we have to add another `#[derive(Accounts)]` to structure the Addition context. For this we need a mutable public calculator account similar to our Create structure but with only one argument. 

```
#[derive(Accounts)]
pub struct Addition<'info> {
    #[account(mut)]
    pub calculator: Account<'info, Calculator>
}
```

All together your final `lib.rs` file should look like this:

```
use anchor_lang::prelude::*;
use anchor_lang::solana_program::entrypoint::ProgramResult;

declare_id!("3PrLAA3B2KJHJKLYxWVe4ihfbh6c3pwvzPsD5dEas7mw");

#[program]
pub mod sol_program {
    use super::*;
    pub fn create(ctx: Context<Create>, init_message: String) -> ProgramResult {
        let calculator = &mut ctx.accounts.calculator;
        calculator.greeting = init_message;
        Ok(())
    }
    pub fn add(ctx: Context<Addition>, num1: i64, num2: i64) -> ProgramResult {
        let calculator = &mut ctx.accounts.calculator;
        calculator.result = num1 + num2;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info>{
    #[account(init, payer=user, space=264)]
    pub calculator: Account<'info, Calculator>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>
}

#[derive(Accounts)]
pub struct Addition<'info> {
    #[account(mut)]
    pub calculator: Account<'info, Calculator>
}

#[account]
pub struct Calculator {
    pub greeting: String,
    pub result: i64,
    pub remainder: i64
}
```

## Testing the Addition Function

For this let's again head back to our `tests/sol-program.ts`. To add a test we add a new `it()` block. This block is structured very similarly to our previous but the key difference is that we are using anchor big numbers to define our inputs. 

```
const assert = require('assert');
const anchor = require('@project-serum/anchor');
const { SystemProgram } = anchor.web3;

describe('sol_program', () => {
    const provider = anchor.getProvider();
    anchor.setProvider(provider);

    const calculator = anchor.web3.Keypair.generate();
    const program = anchor.workspace.SolProgram;

    it('Creates a calculator', async() => {
        await program.rpc.create("Welcome to Solana", {
            accounts: {
                calculator: calculator.publicKey,
                user: provider.wallet.publicKey,
                systemProgram: SystemProgram.programId
            },
            signers: [calculator]
        });

        const account = await program.account.calculator.fetch(calculator.publicKey);
        assert.ok(account.greeting == "Welcome to Solana")
    })
    it('Adds two numbers', async() => {
        await program.rpc.add(new anchor.BN(2), new anchor.BN(3), {
            accounts: {
                calculator: calculator.publicKey
            }
        })
        const account = await program.account.calculator.fetch(calculator.publicKey)
        assert.ok(account.result.eq(new anchor.BN(5)))
    })
})
```

Once this is updated we are ready to run the `anchor test` again. 

![image](https://github.com/jvick1/Intro_to_SOL/assets/32043066/08ccf4db-a604-4ccd-8941-857fc70bb348)
